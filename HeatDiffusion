"""
-----------------------------------------------------------
One Dimensional Heat Diffusion Simulation

Two walls separated by length L of different temperatures 
solving for thediffusion of heat in between the walls
-----------------------------------------------------------
"""

import numpy as np 
import matplotlib.pyplot as plt


# Initial Variables
L = 0.1                 # meters, length L for the distance between the two walls
n = 10                  # number of cells or nodes between the walls
T0 = 0                  # Celcius, initial temperature of region in between walls
T1s = 40                # Celcius, initial temperature of the left wall
T2s = 20                # Celcius, initial temperature of the right wall
dx = L/n                # length of cell
alpha = 0.0001          # Watts/(meter * Kelvin), thermal conductivity
t_final = 2            # seconds, final time
dt = 1                # time step

x = np.linspace(dx/2, L-dx/2, n)    # vector of reference points for each node at the center of the node

T = [[T0 for x in range(n)] for y in range(int(60/0.1))]
# T = np.ones(n) * T0     # vector of starting temperatures
dTdt = np.empty(n)      # vector for temperature derivatives

t = np.arange(0, t_final, dt)       # vector of time steps



# Computation
# plt.ion()                    # interactive mode

for i in range(0, len(t)):       # time step loop
    # plt.clf()                    # clear figure
    for j in range(1, n-1):         # temperatures of each node in i time step
        dTdt[j] = alpha * (-(T[i][j]-T[i][j-1])/dx**2 + (T[i][j+1]-T[i][j])/dx**2)        # 1D heat diffusion equation
        T[i][j] = T[i][j] + dTdt[j] * dt
    dTdt[0] = alpha * (-(T[i][0]-T1s)/dx**2 + (T[i][1]-T[i][0])/dx**2)                 # special boundary condition for left wall
    T[i][0] = T[i][0] + dTdt[0]*dt

    dTdt[n-1] = alpha * (-(T[i][n-1]-T[i][n-2])/dx**2 + (T2s-T[i][n-1])/dx**2)         # special boundary condition for the right wall
    T[i][n-1] = T[i][n-1] + dTdt[n-1]*dt
    


    # plt.figure(1)
    # plt.plot(x,T)
    # plt.axis([0, L, 0, 50])
    # plt.xlabel('Distance (m)')
    # plt.ylabel('Temperature (C)')
    # plt.show()
    # plt.pause(0.01)

for i in range(0, len(t)):
    print(T)
    print('\n')



"""
Initial variables:
-------------------

L length
n nodes
T0 temperature at left wall

vector of temperatures that define temperature at each node
T1s
T2s

dx = L/n
alpha
t_final
dt = 0.1

x = np.linspace(dx/2, L-dx/2, n)    create a reference point at the center of each node: dx/2, starting at dx/2, ending at L-dx/2

T = np.ones(n)*T0   creates a column that is 1 row, n columns, multiplied by starting temperature
dTdt = np.empty(n)  initializes a vector to fill later with derivatives

t = np.arange(0, t_final, dt)   time vector



Computation:
-------------

for j in range(1, len(t)):       time steps, "len" for length
    plt.clf
    for i in range(1, n-1):         number of elements, evaluate derviative for each node
        dTdt[i] = alpha*(-(T[i]-T[i-1])/dx**2+(T[i+1]-T[i])/dx**2)      ** for exponent
    dTdt[0] = alpha*(-(T[0]-T1s/dx**2+(T[1]-T[0])/dx**2)      special condition for left boundary, T[i-1] can't be negative, so which is why we have T1s
    dTdt[n-1] = alpha*(-(T[n-1]-T[n-2]/dx**2+(T2s-T[n-1])/dx**2)        no T[2] node, we we need other surface boundary condition T2s
    T = T + dTdt*dt
    plt.figure(1)
    plt.plot(x,T)
    plt.axis([0, L, 0, 50])    0-L on x axis, 0-50 on y axis
    plt.xlabel('Distance (m)')
    plt.ylabel('Temperature (C)')
    plt.show

"""